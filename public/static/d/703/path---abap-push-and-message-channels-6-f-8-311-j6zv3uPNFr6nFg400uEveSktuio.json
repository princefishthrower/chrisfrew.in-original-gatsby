{"data":{"site":{"siteMetadata":{"title":"Chris Frewin's Full Stack Blog.","author":"Chris Frewin"}},"markdownRemark":{"id":"c1c7ac29-b184-5fc6-a1b7-4f1a659ad325","excerpt":"Add some spice to your SAPUI5 apps! (Or even normal webapps, for that matter) In short, I was a noob.  I once wrote a SAPUI5 app that wouldâ€¦","html":"<h1>Add some spice to your SAPUI5 apps!</h1>\n<h2>(Or even normal webapps, for that matter)</h2>\n<p>In short, I was a noob. </p>\n<p>I once wrote a SAPUI5 app that would display a stream warehouse task code from a warehouse in realtime. How did I do it?</p>\n<p>I wrote a <code class=\"language-text\">window.setInterval()</code> function that would ping table <code class=\"language-text\">/SCWM/WT</code> ðŸ˜Š and check for any new lines - with an OData <code class=\"language-text\">GET_ENTITY_SET</code> server request. ðŸ˜Š ðŸ˜Š</p>\n<p>Yeah.</p>\n<p>Although this may initially sound fine - its not an optimal solution for a few reasons, listed here in terms of level of inefficiency:</p>\n<ol>\n<li>The database is constantly queried, which can potentially slow down DB transactions if the app was run at scale or if the <code class=\"language-text\">setInterval()</code> speed was increased.</li>\n<li>There is a lot of load on the frontend in terms of input/output traffic - there can be a relatively large JSON array sent to the frontend if within the last interval if a large amount of warehouse tasks were created in that interval.</li>\n<li>The query method is simply a bad user experience! Imagine, you wonâ€™t be seeing the warehouse tasks in real time - only the new ones appearing in batches that have been created within the interval of whatever that <code class=\"language-text\">setInterval()</code> function is set to. (Itâ€™s 2020, UI/UX is king ðŸ‘‘ right?)</li>\n</ol>\n<h2>Websockets to the Rescue</h2>\n<p>Well, I was informed of the concept of websockets from one of our consultants. Then I was even luckier to learn a bit more about the technical aspects (when to subscribe, unsubscribe, destroy, and create websockets instances from actions on the front end).</p>\n<p>So hereâ€™s how to add websockets to your SAPUI5 app<sup><a href=\"#footnote-1\">1</a></sup>.</p>\n<h2>SAP Transactions</h2>\n<p>All backend push and messaging channels can be managed with just two transactions: <code class=\"language-text\">SAMC</code>, for message channels and <code class=\"language-text\">SAPC</code>, for push channels. Easy enough.</p>\n<h2>Creating a Message Channel</h2>\n<p>As we will see, to create a proper push channel, we will first need a message channel, so that is where we start off. An ABAP message channel is a way of subscribing current programs to any - the best thing about push channels is that if the push channel <em>isnâ€™t</em> listening, there is no error and nothing else negative happens anywhere else in the system - that is, granted you <code class=\"language-text\">TRY</code> and <code class=\"language-text\">CATCH</code> your push channel messaging properly.</p>\n<p>So letâ€™s get started in transaction <code class=\"language-text\">SAMC</code>:</p>\n<p><img src=\"\"></p>\n<p>We define the message channel name, and, most importantly, define what programs can use this message channel and what type of message this channel will handle (there are only 2 - numeric and string)</p>\n<p>Now, as I mention before, we use these channels to hook into any ABAP program, so that any time they are executed by anyone (or anything) in the system, the channel will be messaged. A safe way to hook into an existing program (using our newly created <code class=\"language-text\">Z_AWESOME_CHANNEL</code>) looks as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"><span class=\"token keyword\">REPORT</span> my_super_cool_existing_report</code></pre></div>\n<h2>Creating a Push Channel</h2>\n<p>Ok, now we head to transaction <code class=\"language-text\">SAPC</code> - we are no going to define a websocket that will be hooked up to our push channel. That way, when something happens in our program, it will message to all subscribed channels, which will be forwarded , and then ultimately, to the most important part, the frontend for our user to see!</p>\n<h2>Frontend</h2>\n<p>On the frontend I create a general websocket function that creates a websocket instance. In order to have the correct service for each view, upon each view change I call this function, which always creates a new instance if there exists a websocket instance already. This way we are sure that on any view change, we have a fresh running instance of the websocket doing the correct task for this view.</p>\n<p>That function looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"></code></pre></div>\n<p>Note that you of course have to use <code class=\"language-text\">ws://</code> as the protocol in the link name!</p>\n<p>On the backend, that ends up looking like a <code class=\"language-text\">CASE</code> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"><span class=\"token keyword\">CASE</span></code></pre></div>\n<h2>Code</h2>\n<p>Yep, youâ€™re going to have to write some ABAP code too. Luckily for us, when we create a push channel in transaction SAPC, SAP generates a class skeleton with 4 methods:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"></code></pre></div>\n<h2>Websocket Advantages</h2>\n<p>In summary, what are the advantages we got by using a websocket?</p>\n<ol>\n<li>Reduced the load on the DB - in fact we totally removed the load on the DB, moving all channel publishing code to our custom class handling new warehouse tasks (which already existed for other reasons anyway)!</li>\n<li>Reduced the input traffic from the ABAP server - what was before be an array of multiple JSON objects, using the new websocket version we are always guaranteed a single JSON object from a given warehouse task.</li>\n<li>Improved the user experience greatly - now users really <em>do</em> see the warehouse tasks appearing in realtime - not in annoying 10 second interval packets.</li>\n</ol>\n<p>Finally, I want to be very clear - in no way should websockets replace <em>all</em> of you I/O in any given app - and indeed for many tasks, using a websocket would actually be detrimental. In the case of my intial app load and warehouse task listing, I actually load the most recently dispatched tasks. In this case it is exactly conceptually correct via a GET call. Itâ€™s only the <em>streaming</em> of <em>new</em> warehouse tasks where the websocket</p>\n<hr/>\n<h1>Footnotes</h1>\n<div id=\"footnote-1\">\n1. Note that unfortunately the Cloud Connector SAP Web IDE does not yet support websockets, that is, without network wizardry. I haven't managed to get it to work. I've left long ago a message with the person who was the lead on Cloud Connector asking if websocket (`ws` protocol) would eventually be supported, but haven't heard anything.\n</div>","frontmatter":{"title":"ABAP Push and Message Channels","date":"January 14, 2020","draft":false,"starID":50,"postType":"dev"}}},"pageContext":{"slug":"/abap-push-and-message-channels/","prev":{"fields":{"slug":"/goals-for-2020/"},"frontmatter":{"date":"12 January, 2020","title":"Goals For 2020","draft":false,"starID":456789,"postType":"misc","link":"https://chrisfrew.in/goals-for-2020/","relativeLink":"/goals-for-2020/"}},"next":null}}